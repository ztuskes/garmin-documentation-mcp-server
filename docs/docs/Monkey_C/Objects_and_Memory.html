<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2025"><meta name="DC.rights.owner" content="(C) Copyright 2025"><meta name="DC.type" content="topic"><meta name="DC.format" content="HTML5"><meta name="DC.identifier" content="objects-modules-and-memory"><link rel="stylesheet" type="text/css" href="../../branding/commonltr.css"><link rel="stylesheet" type="text/css" href="../../branding/style.css"><title>Objects, Modules, and Memory</title></head><body id="objects-modules-and-memory"><header role="banner"><div>
<link href="../../resources/programmers-guide/google-code-prettify/prettify.css" type="text/css" rel="stylesheet">
<script src="../../resources/programmers-guide/jquery-1.11.3.min.js"></script>
<script>
    $(document).ready( function() {
        $( 'pre' ).addClass( 'prettyprint' );
    } );
</script>
<script src="../../resources/programmers-guide/google-code-prettify/run_prettify.js"></script>
</div></header><nav role="toc"><ul><li><a href="../../docs/Readme/Intro.html">Introduction</a></li><li><a href="../../docs/Connect_IQ_Basics/Welcome_to_the_Jungle.html">Welcome to Connect IQ</a></li><li><a href="../../docs/Monkey_C/Basic_Syntax.html">Hello Monkey C!</a><ul><li><a href="../../docs/Monkey_C/Functions.html">Functions</a></li><li class="active"><a href="../../docs/Monkey_C/Objects_and_Memory.html">Objects, Modules, and Memory</a></li><li><a href="../../docs/Monkey_C/Containers.html">Containers</a></li><li><a href="../../docs/Monkey_C/Monkey_Types.html">Monkey Types</a></li><li><a href="../../docs/Monkey_C/Exceptions_and_Errors.html">Exceptions and Errors</a></li><li><a href="../../docs/Monkey_C/Annotations.html">Annotations</a></li><li><a href="../../docs/Monkey_C/Coding_Conventions.html">Coding Conventions</a></li><li><a href="../../docs/Monkey_C/Compiler_Options.html">Compiler Options</a></li></ul></li><li><a href="../../docs/Core_Topics/Overview.html">Core Topics</a></li><li><a href="../../docs/User_Experience_Guidelines/Overview.html">User Experience Guidelines</a></li><li><a href="../../docs/Personality_Library/Personality_UI.html">Personality UI</a></li><li><a href="../../docs/Connect_IQ_FAQ/Overview.html">Connect IQ FAQ</a></li><li><a href="../../docs/Reference_Guides/Overview.html">Reference Guides</a></li><li><a href="../../docs/App_Review_Guidelines/Overview.html">Garmin Connect IQ App Review Guidelines</a></li><li><a href="../../docs/Monetization/Overview.html">Connect IQ Monetization System</a></li><li><a href="../../docs/Device_Reference/Overview.html">Device Reference</a></li></ul></nav><main role="main"><article role="article" aria-labelledby="ariaid-title1"><h1 class="title topictitle1" id="ariaid-title1">Objects, Modules, and Memory</h1><div class="body"><p class="p">Objects are created with the <code class="ph codeph">class</code> keyword. Classes allow data and operations to be bound together on an object. In Monkey C, variables, functions, and other classes can be defined within a class.</p></div><article class="topic nested1" aria-labelledby="ariaid-title2" id="constructors"><h2 class="title topictitle2" id="ariaid-title2">Constructors</h2><div class="body"><p class="p">When an object is instantiated with the <code class="ph codeph">new</code> keyword, the memory is allocated and the <code class="ph codeph">initialize</code> method is called:</p><pre class="pre codeblock typescript"><code>class Circle
{
    protected var mRadius;
    public function initialize( aRadius ) {
      mRadius = aRadius;
    }
}

function createCircle() {
    var c = new Circle( 1.5 );
}</code></pre><p class="p">Within a method implementation you can refer to your current instance using either the <code class="ph codeph">self</code> or <code class="ph codeph">me</code> keywords.</p><pre class="pre codeblock java"><code>class A
{
    public var x;
    public var y;
    public function initialize() {
        me.x = "Hello"; // Set current instance x variable
        self.y = "Hello"; // Set current instance y variable
    }
}</code></pre><p class="p">To instantiate an inner class of nested classes, you must first instantiate the outer class. However, unlike Java, nested classes in Monkey C do not have access to the members of the enclosing class.</p></div></article><article class="topic nested1" aria-labelledby="ariaid-title3" id="inheritance"><h2 class="title topictitle2" id="ariaid-title3">Inheritance</h2><div class="body"><p class="p">Monkey C uses the <code class="ph codeph">extends</code> keyword to support class inheritance:</p><pre class="pre codeblock typescript"><code>import Toybox.System;

class A
{
    function print() {
        System.print( "Hello!" );
    }
}

class B extends A
{

}

function usageSample() {
    var inst = new B();
    inst.print();           // Prints "Hello!"
}</code></pre><p class="p">You can call superclass methods by using the super class's symbol:</p><pre class="pre codeblock java"><code>import Toybox.System;

class A
{
    function print() {
        System.print( "Hello!" );
    }
}

class B extends A
{
    function print() {
        // Call the super class implementation
        A.print();

        // Amend the output
        System.println( "Hola!" );
    }
}

function usageSample() {
    var inst = new B();
    inst.print();           // Prints "Hello! Hola!"
}</code></pre></div></article><article class="topic nested1" aria-labelledby="ariaid-title4" id="data-hiding"><h2 class="title topictitle2" id="ariaid-title4">Data Hiding</h2><div class="body"><p class="p">Class members have three levels of access — <code class="ph codeph">public</code>, <code class="ph codeph">protected</code>, and <code class="ph codeph">private</code>.</p><p class="p"><code class="ph codeph">public</code> is the default, but it can also be explicitly specified. When the <code class="ph codeph">public</code> access modifier is used for an enum, variable, or function, those members are visible to all other classes.</p><p class="p">The <code class="ph codeph">private</code> modifier specifies that the member can only be accessed in its own class.</p><p class="p">The <code class="ph codeph">protected</code> modifier specifies that the member can only be accessed by its own class or one of its subclasses. The <code class="ph codeph">hidden</code> keyword is synonymous with the <code class="ph codeph">protected</code> keyword. Monkey C version 1.0 only had two visibility levels: <code class="ph codeph">public</code> and <code class="ph codeph">hidden</code>. <code class="ph codeph">hidden</code> remains for backwards compatibility purposes but can be considered the same as <code class="ph codeph">protected</code>.</p><pre class="pre codeblock typescript"><code>import Toybox.System;

class Foo
{
    public var publicVar;
    protected var _protectedVar
    private var _privateVar;

    public function initialize() {
        publicVar = "a";
        _protectedVar = "b";
        _privateVar = "c";
    }
}

class Bar extends Foo {
    public function initialize() {
        // Initialize the parent
        Foo.initialize();
        publicVar = "b";
        _protectedVar = "c";
        // Error - can't access private member
        _privateVar = "d";
    }
}

function usageSample() {
    var v = new Foo();
    System.println( v.publicVar );
    // Error - cannot access protected member
    System.println( v._protectedVar );
    // Error - cannot access private member
    System.println( v._privateVar );
}</code></pre></div></article><article class="topic nested1" aria-labelledby="ariaid-title5" id="polymorphism"><h2 class="title topictitle2" id="ariaid-title5">Polymorphism</h2><div class="body"><p class="p">Most object-oriented languages support a concept of <em class="ph i">polymorphic functions</em> in which a function can have multiple definitions based on the input parameter quantity and type. Partially because of its duck-typed nature, Monkey C does not support this kind of runtime polymorphism.</p><p class="p">Because function parameters are duck typed, it is possible to implement some level of polymorphism using the <code class="ph codeph">instanceof</code> operator:</p><pre class="pre codeblock typescript"><code>import Toybox.Lang;

function aPolymorphicFunction(a) {
    switch(a) {
        case instanceof String:
            return doTheStringVersion(a);
        case instanceof Number:
        case instanceof Long:
            return doTheNumericVersion(a);
        default:
            throw new UnexpectedTypeException();
    }

}</code></pre><p class="p">This kind of pattern works when the function expects the same number of inputs. If your function needs to expect multiple inputs, another pattern is to use the options dictionary. You can use symbols to define the keys to maximize processing efficiency:</p><pre class="pre codeblock typescript"><code>x = aPolymorphicFunction({
    :param1=&gt;"Foo",
    :param2=&gt;"Bar"
})</code></pre><p class="p">This pattern is good when you want to leave room for an API to expand in the future.</p></div></article><article class="topic nested1" aria-labelledby="ariaid-title6" id="strong-and-weak-references"><h2 class="title topictitle2" id="ariaid-title6">Strong and Weak References</h2><div class="body"><p class="p">Monkey C is reference counted, which means the runtime system will free memory when the number of objects referencing that memory decrements to zero. Reference counting allows memory to become available very quickly which is important in low memory environments. The kryptonite of reference counting are <em class="ph i">circular references</em>. A circular reference happens when a cycle is formed in the reference chain. For example, imagine object C references object A, object A references object B, <em class="ph i">and</em> object B references object A.</p><br><img class="image" src="../../resources/programmers-guide/weak-reference-1.png" alt="presentation"><br><p class="p">Now C gets invited to sit at the cool-kid table, so it dereferences A so it can hang out with its <em class="ph i">real</em> friends<a name="fnsrc_1" href="#fntarg_1"><sup>1</sup></a>.</p><br><img class="image" src="../../resources/programmers-guide/weak-reference-2.png" alt="Weak References"><br><p class="p">This forms a roundabout to nowhere. The memory for A and B should be freed at this point, but A and B both have a reference count of one because they reference each other. The memory used by A and B are now unavailable to objects from the cool-kids table.</p><p class="p">Sometimes B really does need to reference A. In these cases, you can use a <em class="ph i">weak reference</em>. A weak reference is an object that keeps a reference to an object but does not increment the reference count. This means the object reference can be destroyed, and is a case that should be handled.</p><br><img class="image" src="../../resources/programmers-guide/weak-reference-3.png" alt="Weak References"><br><p class="p">To create a weak reference you use the <code class="ph codeph">weak()</code> method. Weak is a method in <code class="ph codeph">Lang.Object</code> and is available to all Monkey C objects.</p><pre class="pre codeblock java"><code>// I would make a "Hans and Franz" reference but I
// think certain advertising has made them uncool.
var weakRef = obj.weak()</code></pre><p class="p">If you are calling <code class="ph codeph">weak</code> on one of the immutable types (<code class="ph codeph">Number</code>, <code class="ph codeph">Float</code>, <code class="ph codeph">Char</code>, <code class="ph codeph">Long</code>, <code class="ph codeph">Double</code>, <code class="ph codeph">String</code>), then it returns the object itself. Otherwise it will return a <a class="xref" href="https://developer.garmin.com/connect-iq/api-docs/Toybox/Lang/WeakReference.html" target="_blank">Lang.WeakReference</a> instance.</p><pre class="pre codeblock typescript"><code>//! A weak reference is a loosely bound reference to
//! another object. If all strong references have been
//! freed, the get() method will return null.
//! This allows the developer to avoid circular references.
//! @since 1.2.0
class WeakReference
{
    //! Return if the reference is still alive.
    //! @return true if object is still alive, false otherwise.
    //!    When you are dead I will be STILL ALIVE
    //!    I feel fantastic and I am STILL ALIVE
    function stillAlive();

    //! Get the object referenced.
    //! @return Object referenced, or null if object is no
    //!         longer alive.
    function get();
}</code></pre><p class="p">You can use the <code class="ph codeph">stillAlive</code> method to check if the reference has been cleaned up. Use <code class="ph codeph">get</code> to create a strong reference to the object. Only keep the strong reference during the scope you need it!</p><pre class="pre codeblock java"><code>// This is a triumph...
if( weakRef.stillAlive() ) {
    var strongRef = weakRef.get();
    strongRef.doTheThing();
}</code></pre></div><article class="topic nested2" aria-labelledby="ariaid-title7" id="handles-and-heap-allocation"><h3 class="title topictitle3" id="ariaid-title7">Handles and Heap Allocation</h3><div class="body"><p class="p">The heap memory limit varies on a per device basis. Starting with version 2.4.x, Connect IQ uses a dynamically allocated heap for memory handles. Each unique object takes up one memory handle. Object references do not have unique allocations and only reference the memory handle of the object. Older versions of Connect IQ have a smaller, static limit for objects defined by the device. Reaching the object limit in either version will cause a runtime error.</p></div></article></article><article class="topic nested1" aria-labelledby="ariaid-title8" id="modules"><h2 class="title topictitle2" id="ariaid-title8">Modules</h2><div class="body"><p class="p">Modules in Monkey C allow for the scoping of classes and functions. Unlike Java packages, Monkey C modules have many of the same properties as classes. You can have variables, functions, classes, and other modules at the module level:</p><pre class="pre codeblock java"><code>module MyModule
{
    class Foo
    {
        var mValue;
    }
    var moduleVariable;
}

function usageSample() {
    MyModule.moduleVariable = new MyModule.Foo();
}</code></pre><p class="p">However, unlike classes in Monkey C, modules have no concept of inheritance or data hiding (the <code class="ph codeph">extends</code>, <code class="ph codeph">private</code>, and <code class="ph codeph">protected</code> keywords are not supported for modules).</p></div><article class="topic nested2" aria-labelledby="ariaid-title9" id="import-and-using-statements"><h3 class="title topictitle3" id="ariaid-title9">Import and Using Statements</h3><div class="body"><p class="p">You can bring a module into your scoping level with the <code class="ph codeph">import</code> keyword. When you use <code class="ph codeph">import</code> it will bring the <em class="ph i">module suffix and all classes in the module into the type namespace</em>. This allows classes in a module to be accessed without the module suffix, making for easier typing. Function invocations still require the module suffix to be accessed.</p><pre class="pre codeblock typescript"><code>import Toybox.Lang;
import Toybox.System;

// Import lets you say goodbye to
// module prefixes
var globalX as Number or String = 0;

function hasANumber() {
    globalX = 2;  // Allowed
    globalX = "2"; // Allowed
    // Still require prefixes in code
    System.println("globalX = " + globalX);
}</code></pre><p class="p">You can also bring a module into your scoping level with the <code class="ph codeph">using</code> keyword. <code class="ph codeph">using</code> allows a module to be imported into another class or module by a symbol:</p><pre class="pre codeblock java"><code>using Toybox.System;

function foo() {
    System.print( "Hello" );
}</code></pre><p class="p">The <code class="ph codeph">as</code> clause provides a way to assign a module to a different name within scope. This is useful for shortening module names or when you simply disagree with our naming scheme:</p><pre class="pre codeblock java"><code>using Toybox.System as Sys;

function foo() {
    Sys.print( "Hello" );
}</code></pre><p class="p"><code class="ph codeph">using</code> statements are scoped to the class or module in which they are defined.</p><p class="p">The difference between <code class="ph codeph">import</code> and <code class="ph codeph">using</code> is subtle. <code class="ph codeph">import</code> brings the module name and class names into the namespace, where <code class="ph codeph">using</code> only brings the module name into the namespace. If you are using <a class="xref" href="Monkey_Types.html#monkeytypes">monkeytypes</a> you should use <code class="ph codeph">import</code> exclusively, as it will save you a lot of redundant module references. Finally, the <code class="ph codeph">as</code> clause is only supported for <code class="ph codeph">using</code> statements.</p></div></article></article><article class="topic nested1" aria-labelledby="ariaid-title10" id="scoping"><h2 class="title topictitle2" id="ariaid-title10">Scoping</h2><div class="body"><p class="p">Monkey C is a message-passed language. When a function is called, the virtual machine does a look up operation at runtime to find the function being called. Here is the hierarchy that it will search:</p><ol class="ol"><li class="li"><p class="p">Instance members of the class</p></li><li class="li"><p class="p">Members of the superclass</p></li><li class="li"><p class="p">Static members of the class</p></li><li class="li"><p class="p">Members of the parent module, and the parent modules up to the global namespace</p></li><li class="li"><p class="p">Members of the superclass's parent module up to the global namespace</p></li><li class="li"><p class="p">Public static members of the parent module, and the parent modules up to the global namespace</p></li><li class="li"><p class="p">Public static members of the superclass’s parent module up to the global namespace</p></li></ol><p class="p">For example, if function <code class="ph codeph">a()</code> is called on an instance of <code class="ph codeph">Child()</code>, it will be able to access non-member functions <code class="ph codeph">b()</code>, <code class="ph codeph">c()</code>, and <code class="ph codeph">d()</code> when:</p><ul class="ul"><li class="li"><p class="p"><code class="ph codeph">b()</code> is a member of the parent module of the object</p></li><li class="li"><p class="p"><code class="ph codeph">c()</code> is a static member of the object</p></li><li class="li"><p class="p"><code class="ph codeph">d()</code> is a member of the parent module of the parent module, also known as the globals module</p></li></ul><p class="p">The code below tries to clarify:</p><pre class="pre codeblock typescript"><code>import Toybox.System;

// A globally visible function
function d() {
    System.print( "this is D!" );
}

module Parent
{
    // A module function.
    function b() {
        System.print( "This is B!" );
        d(); // Call a globally visible function
    }

    // A child class of a Parent module
    class Child
    {
        // An instance method of Child
        function a() {
            System.print( "This is A!" );
            b(); // Call a function in our parent module
            c(); // Call a static function within the class.
            d(); // Call a globally visible function.
        }

        // A static function of Child.
        // Note that static methods can't call instance method but still have
        // access to parent modules.
        static function c() {
            System.print( "This is C!" );
            b(); // Call a method in the parent module.
            d(); // Call a globally visible function
        }
    }
}</code></pre><p class="p">Sometimes you want to run your search from the global namespace instead of your current scope. You can do this using the bling symbol <code class="ph codeph">$</code>. The bling symbol refers to global scope:</p><pre class="pre codeblock java"><code>function helloFunction() {
    System.println("Hello Hello");
}

class A {
     function helloFunction() {
        System.println("Every time I say goodbye you say hello");
     }

    function b() {
        // Call global helloFunction
        $.helloFunction();
        // Call instance helloFunction
        helloFunction();
    }
}</code></pre><p class="p">If you are referring to a global variable, using bling can improve runtime performance<a name="fnsrc_2" href="#fntarg_2"><sup>2</sup></a>:</p><pre class="pre codeblock java"><code>var globalScopedVariable = "Global String";

module A
{
    class B
    {
        function c() {
            // To find globalScopedVariable, the VM will search at runtime:
            //     instance B
            //     instance B's superclass Toybox.Lang.Object
            //     Module A
            //     Module A's parent globals
            // and finally find globalScopedVariable.
            System.println(globalScopedVariable);
            // This will search only the global namespace for globalScopedVariable.
            // Thanks bling!
            System.println($.globalScopedVariable);
        }
    }
}</code></pre><p class="p">Because Monkey C is dynamically typed, referencing a global variable will search your Object's inheritance structure and the module hierarchy before it will eventually find the global variable. Using the bling symbol we can search globals directly.</p></div></article><div class="fn"><a name="fntarg_1" href="#fnsrc_1"><sup>1</sup></a>  Not that this ever happened to the author.</div><div class="fn"><a name="fntarg_2" href="#fnsrc_2"><sup>2</sup></a>  Do not forget to match your bling with pieces of flair; you can't have enough of either.</div></article></main><footer role="contentinfo"><div>
<p class="disclaimer">
Connect IQ System None API 8.2.3 Documentation. Copyright 2025 Garmin International. All Rights Reserved.
</p>
</div></footer></body></html>